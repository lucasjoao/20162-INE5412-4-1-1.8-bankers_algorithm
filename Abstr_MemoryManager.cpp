/*
 * File:   MemoryManager.cpp
 * Authors: INSERT YOUR NAME HERE
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE (THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION)
 *
 * Created on ...
 */


#include "Simul_Debug.h"
#include "Abstr_MemoryManager.h"
#include "Simulator.h"
#include "Traits.h"

#include <iostream>


MemoryManager::MemoryManager() {
  _chunks = new std::list<MemoryChunk*>();
}

MemoryManager::MemoryManager(const MemoryManager& orig) {
}

MemoryManager::~MemoryManager() {
}

bool MemoryManager::banker(std::vector<unsigned int> *ids,
    std::vector<unsigned int> *hasMems, std::vector<unsigned int> *needMems,
    int i, unsigned int request) {

  Debug::cout(Debug::Level::trace, "MemoryManager::banker");

  auto used = 0;
  std::vector<bool>* finishedJob;
  for (int j = 0; j < ids->size(); j++) {
    used += hasMems->at(j);
    finishedJob->push_back(false);
  }
  auto memorySize = Traits<MemoryManager>::physicalMemorySize;
  auto available = memorySize - used;

  bool safe = false;
  if (request > available) {
    return safe;
  } else {
    // available -= request;
    // preciso atualizar quanto ele tem de memória aqui
    bool dontNeedMore = request + hasMems->at(i) >= needMems->at(i);
    if (dontNeedMore) {
      available += hasMems->at(i);
      finishedJob->at(i) = true;
    } else {
      bool iterateAgain = true;
      while (iterateAgain) {
        // aplicar lógica do iterateAgain no começo e se muda
        for (int k = 0; k < ids->size(); k++) {
          if (k == i && finishedJob->at(i)) continue;
          auto askMem = needMems->at(i) - hasMems->at(i);
          // se available >= askMem, então ele executa e atualiza tudo

        }
      }
    }
  }

}

MemoryChunk* MemoryManager::allocateMemory(unsigned int size) {
    Debug::cout(Debug::Level::trace, "MemoryManager::allocateMemory(" + std::to_string(size) + ")");
    // INSERT YOUR CODE TO ALLOCATE MEMORY (A CHUNK) FOR THE PROCESS
    // ...

    return nullptr;
}

void MemoryManager::deallocateMemory(MemoryChunk* chunk) {
    Debug::cout(Debug::Level::trace, "MemoryManager::deallocateMemory(" + std::to_string(reinterpret_cast<unsigned long> (chunk)) + ")");
    // INSERT YOUR CODE TO DEALLOCATE MEMORY (A CHUNK) OF THE PROCESS
    // ...


}

unsigned int MemoryManager::getNumMemoryChunks() {
    // INSERT YOUR CODE TO RETURN THE QUANTITY OF ALLOCATED PARTITIONS
    // ...
    return 0; //_chunks->size();
}

MemoryChunk* MemoryManager::getMemoryChunk(unsigned int index) {
    // INSERT YOUR CODE TO RETURN THE PARTITION AT INDEX index
    // ...

    return nullptr; // CHANGE TO THE CORRET RETURN VALUE
}

void MemoryManager::showMemory() {
    // INSERT YOUR CODE TO SHOW THE MEMORY MAP, IN THE FOLLOWING FORMAT
    // <beginAddress>-<endAddress>: <FREE|ALLOCATED> <size> <process id>

    // Exemplo:
    /*
      0-1499:FREE 1500 0
      1500-1999:ALLOCATED 500 2
      2000-2999:ALLOCATED 1000 3
      3000-9999:FREE 7000 0
      10000-19999:ALLOCATED 10000 7
      20000-1000000:FREE 800000 0
    */
    //std::cout << "Memory Map:" << std::endl;

    // INSERT YOUR CODE TO SHOW THE MEMORY MAP
    // ...

}