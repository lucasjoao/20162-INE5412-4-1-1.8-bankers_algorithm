/*
 * File:   MemoryManager.cpp
 * Authors: INSERT YOUR NAME HERE
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE (THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION)
 *
 * Created on ...
 */


#include "Simul_Debug.h"
#include "Abstr_MemoryManager.h"
#include "Simulator.h"
#include "Traits.h"

#include <iostream>


MemoryManager::MemoryManager() {
  _chunks = new std::list<MemoryChunk*>();
}

MemoryManager::MemoryManager(const MemoryManager& orig) {
}

MemoryManager::~MemoryManager() {
}

bool MemoryManager::banker(std::vector<unsigned int> *ids,
    std::vector<unsigned int> *hasMems, std::vector<unsigned int> *needMems,
    int i, unsigned int request) {

  Debug::cout(Debug::Level::trace, "MemoryManager::banker");

  auto used = 0;
  std::vector<bool>* finishedJob = new std::vector<bool>();
  for (int j = 0; j < ids->size(); j++) {
    used += hasMems->at(j);
    finishedJob->push_back(false);
  }

  auto memorySize = Traits<MemoryManager>::physicalMemorySize;
  auto available = memorySize - used;
  auto availableFixBug = available;
  auto hasMemsFixBug = hasMems->at(i);

  bool safe = false;
  if (request > available) {
    Debug::cout(Debug::Level::info,
      "Estado inseguro, porque foi solicitado pelo processo " +
      std::to_string(ids->at(i)) + " " + std::to_string(request) + " de " +
      "recurso, sendo que há " + std::to_string(available) + " disponível.");
    return safe;
  }

  Debug::cout(Debug::Level::info, "Há " + std::to_string(available) + " de"
    + " memória disponível.");

  bool dontNeedMore = request + hasMems->at(i) >= needMems->at(i);
  if (dontNeedMore) {
    available += hasMems->at(i);
    finishedJob->at(i) = true;
    Debug::cout(Debug::Level::info, "Após solicitar " + std::to_string(request)
      + " de memória, o processo " + std::to_string(ids->at(i)) + " terminará"
      + " o seu trabalho.");
  } else {
    available -= request;
    hasMems->at(i) += request;
    Debug::cout(Debug::Level::info, "Solicitar " + std::to_string(request)
      + " de memória não será suficiente para o processo " +
      std::to_string(ids->at(i)) + " terminar o seu trabalho. Ele ainda " +
      "precisa de " + std::to_string(needMems->at(i) - hasMems->at(i)) + ".");
  }

  bool infiniteLoop;
  while (available != memorySize) {
    infiniteLoop = true;
    for (int k = 0; k < ids->size(); k++) {
      if (k == i && finishedJob->at(i) || finishedJob->at(k)) continue;

      auto askMem = needMems->at(k) - hasMems->at(k);

      Debug::cout(Debug::Level::info, "Há " + std::to_string(available) + " de"
        + " memória disponível.");
      Debug::cout(Debug::Level::info, "Processo " + std::to_string(ids->at(k))
        + " com " + std::to_string(hasMems->at(k)) + " que precisa de "
        + std::to_string(needMems->at(k)) +
        + " quer utilizar " + std::to_string(askMem) + " da memória. Se isso "
        + "acontecer, ficará " + std::to_string(int(available-askMem)) +
        " do recurso disponível enquanto ele trabalha.");

      if (available >= askMem && !finishedJob->at(k)) {
        infiniteLoop = false;
        finishedJob->at(k) = true;
        available += hasMems->at(k);

        Debug::cout(Debug::Level::info,
          "Processo " + std::to_string(ids->at(k)) +
          + " com " + std::to_string(hasMems->at(k)) + " que precisa de "
          + std::to_string(needMems->at(k)) + " usará mais " +
          std::to_string(askMem) + " da memória, terminará seu trabalho e " +
          "deixará " + std::to_string(available) + " do recurso disponível.");
      }
    }

    if (infiniteLoop) break;
  }

  if (available == memorySize) {
    safe = true;
    Debug::cout(Debug::Level::info,
      "A requisição gera um estado seguro, logo pode ser atendida.");
  } else {
    Debug::cout(Debug::Level::info,
      "A requisição gera um estado inseguro, logo não pode ser atendida.");
  }

  available = availableFixBug;
  hasMems->at(i) = hasMemsFixBug;
  return safe;
}

MemoryChunk* MemoryManager::allocateMemory(unsigned int size) {
    Debug::cout(Debug::Level::trace, "MemoryManager::allocateMemory(" + std::to_string(size) + ")");
    // INSERT YOUR CODE TO ALLOCATE MEMORY (A CHUNK) FOR THE PROCESS
    // ...

    return nullptr;
}

void MemoryManager::deallocateMemory(MemoryChunk* chunk) {
    Debug::cout(Debug::Level::trace, "MemoryManager::deallocateMemory(" + std::to_string(reinterpret_cast<unsigned long> (chunk)) + ")");
    // INSERT YOUR CODE TO DEALLOCATE MEMORY (A CHUNK) OF THE PROCESS
    // ...


}

unsigned int MemoryManager::getNumMemoryChunks() {
    // INSERT YOUR CODE TO RETURN THE QUANTITY OF ALLOCATED PARTITIONS
    // ...
    return 0; //_chunks->size();
}

MemoryChunk* MemoryManager::getMemoryChunk(unsigned int index) {
    // INSERT YOUR CODE TO RETURN THE PARTITION AT INDEX index
    // ...

    return nullptr; // CHANGE TO THE CORRET RETURN VALUE
}

void MemoryManager::showMemory() {
    // INSERT YOUR CODE TO SHOW THE MEMORY MAP, IN THE FOLLOWING FORMAT
    // <beginAddress>-<endAddress>: <FREE|ALLOCATED> <size> <process id>

    // Exemplo:
    /*
      0-1499:FREE 1500 0
      1500-1999:ALLOCATED 500 2
      2000-2999:ALLOCATED 1000 3
      3000-9999:FREE 7000 0
      10000-19999:ALLOCATED 10000 7
      20000-1000000:FREE 800000 0
    */
    //std::cout << "Memory Map:" << std::endl;

    // INSERT YOUR CODE TO SHOW THE MEMORY MAP
    // ...

}